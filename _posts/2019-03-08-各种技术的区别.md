---
layout:     post
title:      各种技术的区别
subtitle:   各种技术的区别
date:       2019-03-08
author:     changechenhao
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    -  面试
---

## 前言
面试中老是有人问A与B有什么区别这样的问题，所以已此片文章来记录这些常见技术的区别。

## get 与 post 的区别
- `GET` 请求可被缓存，`POST` 请求不会被缓存
- `GET` 请求保留在浏览器历史记录中，`POST` 请求不会保留在浏览器历史记录中
- `GET` 请求可被收藏为书签，`POST` 不能被收藏为书签
- `GET` 请求不应在处理敏感数据时使用
- `GET` 请求有长度限制，`POST` 请求对数据长度没有要求
- `GET` 请求只应当用于取回数据

## cookie 与 session 的区别

`cookie`是服务器发送给客户端且保存在客户端的一个文本文件，客户端请求服务器的时候，会把`cookie`带上一并
提交给服务器，已此来解决http的无状态性。`cookie`的内容主要包括：名字，值，过期时间，路径和域。
路径与域一起构成`cookie`的作用范围。若不设置过期时间，则表示这个`cookie`的生命期为浏览器会话期间，关闭
浏览器窗口，`cookie`就消失。

`session`机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。
- 存取方式的不同:Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。
`session`中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。
- 隐私策略的不同:`cookie`存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修
正Cookie中的内容。而`session`存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。
- 有效期上的不同：
- 服务器压力的不同:`session`是保管在服务器端的，每个用户都会产生一个`session`。而`cookie`保管在客
户端，不占用服务器资源。
- 浏览器支持的不同:`cooki`e是需要客户端浏览器支持的。
- 跨域支持上的不同:`cookie`的作用域是domain本身以及domain下的所有子域名。

## tcp 与 udp 的区别

`TCP`与`UDP`基本区别：
- 基于连接与无连接
- `TCP`要求系统资源较多，`UDP`较少； 
- `UDP`程序结构较简单 
- 流模式（`TCP`）与数据报模式(`UDP`); 
- `TCP`保证数据正确性，`UDP`可能丢包 
- `TCP`保证数据顺序，`UDP`不保证 

## 如何保证tcp的可靠性
- 校验和


    发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 
- 确认应答+序列号


    TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 
- 超时重传
    
    
    当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 
- 流量控制


    TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。
    接收方有即时窗口（滑动窗口），随ACK报文发送
- 拥塞控制


    当网络拥塞时，减少数据的发送。
    发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小
    慢启动、拥塞避免、拥塞发送、快速恢复

## tcp 为什么三次握手与四次分手
[tcp三次握手](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png)
[tcp四次挥手](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png)

- 保证TCP协议的全双工连接能够可靠关闭
如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，
导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，
此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，
Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合
可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，
能够保证对方收到ACK，最后正确的关闭连接。
- 保证这次连接的重复数据段从网络中消失
如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端
口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊
情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些
延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连
接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数
据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络
中消失。


## 同步与非同步，阻塞与非阻塞
- 同步和异步关注的是消息通信机制.
- 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.
链接：

## 并发与并行
- 并发关键是在是否有处理多个任务的能力，不是同时的
- 并行是同时处理多个任务的能力


## 参考
- tcp 为什么三次握手与四次分手:[https://www.zhihu.com/question/36930631/answer/69631012]()
- 同步与非同步，阻塞与非阻塞:[https://www.zhihu.com/question/19732473/answer/20851256]()
- cookie 与 session:[https://juejin.im/entry/5766c29d6be3ff006a31b84e]()